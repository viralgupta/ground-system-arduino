"use strict";
const electron = require("electron");
const serialport$1 = require("serialport");
const parserReadline = require("@serialport/parser-readline");
const excelJS = require("exceljs");
let serialport;
let data = [];
let position = { x: 0, y: 0, z: 0 };
function mapValueToRange(value, oldMin, oldMax, newMin, newMax) {
  const oldValueRange = oldMax - oldMin;
  const newValueRange = newMax - newMin;
  const normalizedValue = (value - oldMin) / oldValueRange;
  const newValue = normalizedValue * newValueRange + newMin;
  return newValue;
}
const getPorts = async () => {
  const ports = await serialport$1.SerialPort.list();
  const pathlists = ports.map((port) => port.path);
  return {
    ports: pathlists
  };
};
const writePort = async (data2) => {
  if (serialport) {
    serialport.write(data2);
    return { message: "Data written to the device", success: true };
  } else {
    return { message: "No device connected", success: false };
  }
};
const saveData = async () => {
  const path = await electron.ipcRenderer.invoke("dialog:openSave");
  if (!path) {
    return { message: "File Saving Canceled!", success: false };
  }
  const workbook = new excelJS.Workbook();
  const worksheet = workbook.addWorksheet("data");
  worksheet.columns = [
    { header: "Time Stamp", key: "time", width: 25 },
    { header: "Packet Count", key: "packet_count", width: 15 },
    { header: "Altitude", key: "altitude", width: 15 },
    { header: "Pressure", key: "pressure", width: 15 },
    { header: "Temprature 1", key: "temperature1", width: 15 },
    { header: "Temprature 2", key: "temperature2", width: 15 },
    { header: "Voltage", key: "voltage", width: 15 },
    { header: "GPS Time", key: "gnss_time", width: 15 },
    { header: "Latitude", key: "latitude", width: 15 },
    { header: "Longitude", key: "longitude", width: 15 },
    { header: "GPS Altitude", key: "gps_altitude", width: 15 },
    { header: "Sats", key: "sats", width: 15 },
    { header: "Acceleration-X", key: "acceleration_x", width: 15 },
    { header: "Acceleration-Y", key: "acceleration_y", width: 15 },
    { header: "Acceleration-Z", key: "acceleration_z", width: 15 },
    { header: "Gyro-X", key: "gyro_x", width: 15 },
    { header: "Gyro-Y", key: "gyro_y", width: 15 },
    { header: "Gyro-Z", key: "gyro_z", width: 15 },
    { header: "Pitch", key: "pitch", width: 15 },
    { header: "Roll", key: "roll", width: 15 },
    { header: "Yaw", key: "yaw", width: 15 },
    { header: "Heading", key: "heading", width: 15 },
    { header: "Parachute", key: "parachute", width: 15 },
    { header: "Flight State", key: "flight_state", width: 15 },
    { header: "Time Since Start", key: "time_since_start", width: 15 }
  ];
  data.forEach((data2) => {
    worksheet.addRow({ ...data2 });
  });
  try {
    await workbook.xlsx.writeFile(path);
    return { message: "Data saved successfully", success: true };
  } catch (error) {
    return { message: `Error saving data`, success: false };
  }
};
const getStream = async (port) => {
  const connectToDevice = () => {
    serialport$1.SerialPort.list().then((ports) => {
      const matchingPort = ports.find((p) => p.path === port);
      if (matchingPort) {
        serialport = new serialport$1.SerialPort({
          baudRate: 9600,
          path: matchingPort.path
        });
        const parser = serialport.pipe(new parserReadline.ReadlineParser({ delimiter: "\r\n" }));
        parser.on("data", (datas) => {
          const regex = /<([\d.: -]+)>/g;
          const matches = [...datas.matchAll(regex)];
          const values = matches.map((match) => match[1]);
          if (values && values[0] && values[1] && values[2] && values[3] && values[4] && values[5] && values[6] && values[7] && values[8] && values[9] && values[10] && values[11] && values[12] && values[13] && values[14] && values[15] && values[16] && values[17] && values[18] && values[19] && values[20] && values[21] && values[22] && values[23] && values[24]) {
            const newData = {
              time: values[0],
              packet_count: parseInt(values[1]),
              altitude: parseFloat(values[2]),
              pressure: parseFloat(values[3]),
              temperature1: parseFloat(values[4]),
              temperature2: parseFloat(values[5]),
              voltage: parseFloat(values[6]),
              gnss_time: values[7],
              latitude: parseFloat(values[8]),
              longitude: parseFloat(values[9]),
              gps_altitude: parseFloat(values[10]),
              sats: parseInt(values[11]),
              acceleration_x: parseFloat(values[12]),
              acceleration_y: parseFloat(values[13]),
              acceleration_z: parseFloat(values[14]),
              gyro_x: parseFloat(values[15]),
              gyro_y: parseFloat(values[16]),
              gyro_z: parseFloat(values[17]),
              pitch: parseFloat(values[18]),
              roll: parseFloat(values[19]),
              yaw: parseFloat(values[20]),
              heading: parseFloat(values[21]),
              parachute: parseInt(values[22]),
              flight_state: parseInt(values[23]),
              time_since_start: parseFloat(values[24])
            };
            data = [...data, newData];
            position = {
              x: mapValueToRange(values[18], 0, 360, -180, 180),
              y: mapValueToRange(values[21], 0, 360, -180, 180),
              z: mapValueToRange(values[19], 0, 360, -180, 180)
            };
            window.postMessage("fetch-data", "*");
          }
        });
        serialport.on("error", (err) => {
          window.postMessage("serialport-error", "*");
        });
        serialport.on("close", () => {
          window.postMessage("serialport-close", "*");
        });
      } else {
        setTimeout(connectToDevice, 1e3);
      }
    });
  };
  connectToDevice();
};
const closeStream = async () => {
  if (serialport) {
    serialport.close();
  }
};
const getData = () => {
  return data;
};
const getPosition = () => {
  return position;
};
electron.contextBridge.exposeInMainWorld("backend", {
  getPorts,
  writePort,
  saveData,
  getStream,
  closeStream,
  getData,
  getPosition
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXgubWpzIiwic291cmNlcyI6WyIuLi8uLi9lbGVjdHJvbi9wcmVsb2FkL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlwY1JlbmRlcmVyLCBjb250ZXh0QnJpZGdlIH0gZnJvbSAnZWxlY3Ryb24nXHJcbmltcG9ydCB7IFNlcmlhbFBvcnQgfSBmcm9tICdzZXJpYWxwb3J0JztcclxuaW1wb3J0IHsgUmVhZGxpbmVQYXJzZXIgfSBmcm9tICdAc2VyaWFscG9ydC9wYXJzZXItcmVhZGxpbmUnO1xyXG5pbXBvcnQgZXhjZWxKUyBmcm9tICdleGNlbGpzJztcclxuXHJcbmludGVyZmFjZSBEYXRhIHtcclxuICB0aW1lOiBzdHJpbmc7XHJcbiAgcGFja2V0X2NvdW50OiBudW1iZXI7XHJcbiAgYWx0aXR1ZGU6IG51bWJlcjtcclxuICBwcmVzc3VyZTogbnVtYmVyO1xyXG4gIHRlbXBlcmF0dXJlMTogbnVtYmVyO1xyXG4gIHRlbXBlcmF0dXJlMjogbnVtYmVyO1xyXG4gIHZvbHRhZ2U6IG51bWJlcjtcclxuICBnbnNzX3RpbWU6IHN0cmluZztcclxuICBsYXRpdHVkZTogbnVtYmVyO1xyXG4gIGxvbmdpdHVkZTogbnVtYmVyO1xyXG4gIGdwc19hbHRpdHVkZTogbnVtYmVyO1xyXG4gIHNhdHM6IG51bWJlcjtcclxuICBhY2NlbGVyYXRpb25feDogbnVtYmVyO1xyXG4gIGFjY2VsZXJhdGlvbl95OiBudW1iZXI7XHJcbiAgYWNjZWxlcmF0aW9uX3o6IG51bWJlcjtcclxuICBneXJvX3g6IG51bWJlcjtcclxuICBneXJvX3k6IG51bWJlcjtcclxuICBneXJvX3o6IG51bWJlcjtcclxuICBwaXRjaDogbnVtYmVyO1xyXG4gIHJvbGw6IG51bWJlcjtcclxuICB5YXc6IG51bWJlcjtcclxuICBoZWFkaW5nOiBudW1iZXI7XHJcbiAgcGFyYWNodXRlOiBudW1iZXI7XHJcbiAgZmxpZ2h0X3N0YXRlOiBudW1iZXI7XHJcbiAgdGltZV9zaW5jZV9zdGFydDogbnVtYmVyO1xyXG59XHJcblxyXG5sZXQgc2VyaWFscG9ydDogU2VyaWFsUG9ydDtcclxubGV0IGRhdGE6IERhdGFbXSA9IFtdO1xyXG5sZXQgcG9zaXRpb246IHtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG4gIHo6IG51bWJlcjtcclxufSA9IHsgeDogMCwgeTogMCwgejogMCB9O1xyXG5cclxuZnVuY3Rpb24gbWFwVmFsdWVUb1JhbmdlKFxyXG4gIHZhbHVlOiBudW1iZXIsXHJcbiAgb2xkTWluOiBudW1iZXIsXHJcbiAgb2xkTWF4OiBudW1iZXIsXHJcbiAgbmV3TWluOiBudW1iZXIsXHJcbiAgbmV3TWF4OiBudW1iZXJcclxuKSB7XHJcbiAgY29uc3Qgb2xkVmFsdWVSYW5nZSA9IG9sZE1heCAtIG9sZE1pbjtcclxuICBjb25zdCBuZXdWYWx1ZVJhbmdlID0gbmV3TWF4IC0gbmV3TWluO1xyXG5cclxuICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSAodmFsdWUgLSBvbGRNaW4pIC8gb2xkVmFsdWVSYW5nZTtcclxuICBjb25zdCBuZXdWYWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIG5ld1ZhbHVlUmFuZ2UgKyBuZXdNaW47XHJcblxyXG4gIHJldHVybiBuZXdWYWx1ZTtcclxufVxyXG5cclxuY29uc3QgZ2V0UG9ydHMgPSBhc3luYyAoKSA9PiB7XHJcbiAgY29uc3QgcG9ydHMgPSBhd2FpdCBTZXJpYWxQb3J0Lmxpc3QoKVxyXG4gIGNvbnN0IHBhdGhsaXN0cyA9IHBvcnRzLm1hcChwb3J0ID0+IHBvcnQucGF0aClcclxuICByZXR1cm4ge1xyXG4gICAgcG9ydHM6IHBhdGhsaXN0c1xyXG4gIH1cclxufVxyXG5cclxuY29uc3Qgd3JpdGVQb3J0ID0gYXN5bmMgKGRhdGE6IHN0cmluZykgPT4ge1xyXG4gIGlmIChzZXJpYWxwb3J0KSB7XHJcbiAgICBzZXJpYWxwb3J0LndyaXRlKGRhdGEpO1xyXG4gICAgcmV0dXJuIHsgbWVzc2FnZTogJ0RhdGEgd3JpdHRlbiB0byB0aGUgZGV2aWNlJywgc3VjY2VzczogdHJ1ZSB9XHJcbn0gZWxzZSB7XHJcbiAgICByZXR1cm4geyBtZXNzYWdlOiAnTm8gZGV2aWNlIGNvbm5lY3RlZCcsIHN1Y2Nlc3M6IGZhbHNlIH1cclxufVxyXG59XHJcblxyXG5jb25zdCBzYXZlRGF0YSA9IGFzeW5jICgpID0+IHtcclxuICBjb25zdCBwYXRoOiBzdHJpbmcgPSBhd2FpdCBpcGNSZW5kZXJlci5pbnZva2UoJ2RpYWxvZzpvcGVuU2F2ZScpXHJcbiAgaWYgKCFwYXRoKSB7XHJcbiAgICByZXR1cm4geyBtZXNzYWdlOiAnRmlsZSBTYXZpbmcgQ2FuY2VsZWQhJywgc3VjY2VzczogZmFsc2UgfVxyXG4gIH1cclxuXHJcbiAgY29uc3Qgd29ya2Jvb2sgPSBuZXcgZXhjZWxKUy5Xb3JrYm9vaygpO1xyXG4gIGNvbnN0IHdvcmtzaGVldCA9IHdvcmtib29rLmFkZFdvcmtzaGVldChcImRhdGFcIik7XHJcbiAgd29ya3NoZWV0LmNvbHVtbnMgPSBbXHJcbiAgICAgIHsgaGVhZGVyOiBcIlRpbWUgU3RhbXBcIiwga2V5OiBcInRpbWVcIiwgd2lkdGg6IDI1IH0sXHJcbiAgICAgIHsgaGVhZGVyOiBcIlBhY2tldCBDb3VudFwiLCBrZXk6IFwicGFja2V0X2NvdW50XCIsIHdpZHRoOiAxNSB9LFxyXG4gICAgICB7IGhlYWRlcjogXCJBbHRpdHVkZVwiLCBrZXk6IFwiYWx0aXR1ZGVcIiwgd2lkdGg6IDE1IH0sXHJcbiAgICAgIHsgaGVhZGVyOiBcIlByZXNzdXJlXCIsIGtleTogXCJwcmVzc3VyZVwiLCB3aWR0aDogMTUgfSxcclxuICAgICAgeyBoZWFkZXI6IFwiVGVtcHJhdHVyZSAxXCIsIGtleTogXCJ0ZW1wZXJhdHVyZTFcIiwgd2lkdGg6IDE1IH0sXHJcbiAgICAgIHsgaGVhZGVyOiBcIlRlbXByYXR1cmUgMlwiLCBrZXk6IFwidGVtcGVyYXR1cmUyXCIsIHdpZHRoOiAxNSB9LFxyXG4gICAgICB7IGhlYWRlcjogXCJWb2x0YWdlXCIsIGtleTogXCJ2b2x0YWdlXCIsIHdpZHRoOiAxNSB9LFxyXG4gICAgICB7IGhlYWRlcjogXCJHUFMgVGltZVwiLCBrZXk6IFwiZ25zc190aW1lXCIsIHdpZHRoOiAxNSB9LFxyXG4gICAgICB7IGhlYWRlcjogXCJMYXRpdHVkZVwiLCBrZXk6IFwibGF0aXR1ZGVcIiwgd2lkdGg6IDE1IH0sXHJcbiAgICAgIHsgaGVhZGVyOiBcIkxvbmdpdHVkZVwiLCBrZXk6IFwibG9uZ2l0dWRlXCIsIHdpZHRoOiAxNSB9LFxyXG4gICAgICB7IGhlYWRlcjogXCJHUFMgQWx0aXR1ZGVcIiwga2V5OiBcImdwc19hbHRpdHVkZVwiLCB3aWR0aDogMTUgfSxcclxuICAgICAgeyBoZWFkZXI6IFwiU2F0c1wiLCBrZXk6IFwic2F0c1wiLCB3aWR0aDogMTUgfSxcclxuICAgICAgeyBoZWFkZXI6IFwiQWNjZWxlcmF0aW9uLVhcIiwga2V5OiBcImFjY2VsZXJhdGlvbl94XCIsIHdpZHRoOiAxNSB9LFxyXG4gICAgICB7IGhlYWRlcjogXCJBY2NlbGVyYXRpb24tWVwiLCBrZXk6IFwiYWNjZWxlcmF0aW9uX3lcIiwgd2lkdGg6IDE1IH0sXHJcbiAgICAgIHsgaGVhZGVyOiBcIkFjY2VsZXJhdGlvbi1aXCIsIGtleTogXCJhY2NlbGVyYXRpb25felwiLCB3aWR0aDogMTUgfSxcclxuICAgICAgeyBoZWFkZXI6IFwiR3lyby1YXCIsIGtleTogXCJneXJvX3hcIiwgd2lkdGg6IDE1IH0sXHJcbiAgICAgIHsgaGVhZGVyOiBcIkd5cm8tWVwiLCBrZXk6IFwiZ3lyb195XCIsIHdpZHRoOiAxNSB9LFxyXG4gICAgICB7IGhlYWRlcjogXCJHeXJvLVpcIiwga2V5OiBcImd5cm9felwiLCB3aWR0aDogMTUgfSxcclxuICAgICAgeyBoZWFkZXI6IFwiUGl0Y2hcIiwga2V5OiBcInBpdGNoXCIsIHdpZHRoOiAxNSB9LFxyXG4gICAgICB7IGhlYWRlcjogXCJSb2xsXCIsIGtleTogXCJyb2xsXCIsIHdpZHRoOiAxNSB9LFxyXG4gICAgICB7IGhlYWRlcjogXCJZYXdcIiwga2V5OiBcInlhd1wiLCB3aWR0aDogMTUgfSxcclxuICAgICAgeyBoZWFkZXI6IFwiSGVhZGluZ1wiLCBrZXk6IFwiaGVhZGluZ1wiLCB3aWR0aDogMTUgfSxcclxuICAgICAgeyBoZWFkZXI6IFwiUGFyYWNodXRlXCIsIGtleTogXCJwYXJhY2h1dGVcIiwgd2lkdGg6IDE1IH0sXHJcbiAgICAgIHsgaGVhZGVyOiBcIkZsaWdodCBTdGF0ZVwiLCBrZXk6IFwiZmxpZ2h0X3N0YXRlXCIsIHdpZHRoOiAxNSB9LFxyXG4gICAgICB7IGhlYWRlcjogXCJUaW1lIFNpbmNlIFN0YXJ0XCIsIGtleTogXCJ0aW1lX3NpbmNlX3N0YXJ0XCIsIHdpZHRoOiAxNSB9LFxyXG4gIF07XHJcblxyXG4gIGRhdGEuZm9yRWFjaCgoZGF0YSkgPT4ge1xyXG4gICAgd29ya3NoZWV0LmFkZFJvdyh7IC4uLmRhdGEgfSk7IFxyXG4gIH0pO1xyXG5cclxuICB0cnkge1xyXG4gICAgYXdhaXQgd29ya2Jvb2sueGxzeC53cml0ZUZpbGUocGF0aCk7XHJcbiAgICByZXR1cm4geyBtZXNzYWdlOiAnRGF0YSBzYXZlZCBzdWNjZXNzZnVsbHknLCBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiB7IG1lc3NhZ2U6IGBFcnJvciBzYXZpbmcgZGF0YWAsIHN1Y2Nlc3M6IGZhbHNlIH07XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBnZXRTdHJlYW0gPSBhc3luYyAocG9ydDogc3RyaW5nKSA9PiB7XHJcbiAgY29uc3QgY29ubmVjdFRvRGV2aWNlID0gKCkgPT4ge1xyXG4gICAgU2VyaWFsUG9ydC5saXN0KCkudGhlbihwb3J0cyA9PiB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdQb3J0ID0gcG9ydHMuZmluZChwID0+IHAucGF0aCA9PT0gcG9ydCk7XHJcblxyXG4gICAgICAgIGlmIChtYXRjaGluZ1BvcnQpIHtcclxuICAgICAgICAgICAgc2VyaWFscG9ydCA9IG5ldyBTZXJpYWxQb3J0KHtcclxuICAgICAgICAgICAgICAgIGJhdWRSYXRlOiA5NjAwLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogbWF0Y2hpbmdQb3J0LnBhdGhcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBzZXJpYWxwb3J0LnBpcGUobmV3IFJlYWRsaW5lUGFyc2VyKHsgZGVsaW1pdGVyOiAnXFxyXFxuJyB9KSk7XHJcblxyXG4gICAgICAgICAgICBwYXJzZXIub24oJ2RhdGEnLCAoZGF0YXMpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCByZWdleCA9IC88KFtcXGQuOiAtXSspPi9nO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbLi4uZGF0YXMubWF0Y2hBbGwocmVnZXgpXTtcclxuICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IG1hdGNoWzFdKTtcclxuICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMgJiZcclxuICAgICAgICAgICAgICAgIHZhbHVlc1swXSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzFdICYmXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbMl0gJiZcclxuICAgICAgICAgICAgICAgIHZhbHVlc1szXSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzRdICYmXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbNV0gJiZcclxuICAgICAgICAgICAgICAgIHZhbHVlc1s2XSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzddICYmXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbOF0gJiZcclxuICAgICAgICAgICAgICAgIHZhbHVlc1s5XSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzEwXSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzExXSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzEyXSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzEzXSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzE0XSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzE1XSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzE2XSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzE3XSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzE4XSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzE5XSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzIwXSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzIxXSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzIyXSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzIzXSAmJlxyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzI0XVxyXG4gICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgdGltZTogdmFsdWVzWzBdLFxyXG4gICAgICAgICAgICAgICAgICBwYWNrZXRfY291bnQ6IHBhcnNlSW50KHZhbHVlc1sxXSksXHJcbiAgICAgICAgICAgICAgICAgIGFsdGl0dWRlOiBwYXJzZUZsb2F0KHZhbHVlc1syXSksXHJcbiAgICAgICAgICAgICAgICAgIHByZXNzdXJlOiBwYXJzZUZsb2F0KHZhbHVlc1szXSksXHJcbiAgICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlMTogcGFyc2VGbG9hdCh2YWx1ZXNbNF0pLFxyXG4gICAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTI6IHBhcnNlRmxvYXQodmFsdWVzWzVdKSxcclxuICAgICAgICAgICAgICAgICAgdm9sdGFnZTogcGFyc2VGbG9hdCh2YWx1ZXNbNl0pLFxyXG4gICAgICAgICAgICAgICAgICBnbnNzX3RpbWU6IHZhbHVlc1s3XSxcclxuICAgICAgICAgICAgICAgICAgbGF0aXR1ZGU6IHBhcnNlRmxvYXQodmFsdWVzWzhdKSxcclxuICAgICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBwYXJzZUZsb2F0KHZhbHVlc1s5XSksXHJcbiAgICAgICAgICAgICAgICAgIGdwc19hbHRpdHVkZTogcGFyc2VGbG9hdCh2YWx1ZXNbMTBdKSxcclxuICAgICAgICAgICAgICAgICAgc2F0czogcGFyc2VJbnQodmFsdWVzWzExXSksXHJcbiAgICAgICAgICAgICAgICAgIGFjY2VsZXJhdGlvbl94OiBwYXJzZUZsb2F0KHZhbHVlc1sxMl0pLFxyXG4gICAgICAgICAgICAgICAgICBhY2NlbGVyYXRpb25feTogcGFyc2VGbG9hdCh2YWx1ZXNbMTNdKSxcclxuICAgICAgICAgICAgICAgICAgYWNjZWxlcmF0aW9uX3o6IHBhcnNlRmxvYXQodmFsdWVzWzE0XSksXHJcbiAgICAgICAgICAgICAgICAgIGd5cm9feDogcGFyc2VGbG9hdCh2YWx1ZXNbMTVdKSxcclxuICAgICAgICAgICAgICAgICAgZ3lyb195OiBwYXJzZUZsb2F0KHZhbHVlc1sxNl0pLFxyXG4gICAgICAgICAgICAgICAgICBneXJvX3o6IHBhcnNlRmxvYXQodmFsdWVzWzE3XSksXHJcbiAgICAgICAgICAgICAgICAgIHBpdGNoOiBwYXJzZUZsb2F0KHZhbHVlc1sxOF0pLFxyXG4gICAgICAgICAgICAgICAgICByb2xsOiBwYXJzZUZsb2F0KHZhbHVlc1sxOV0pLFxyXG4gICAgICAgICAgICAgICAgICB5YXc6IHBhcnNlRmxvYXQodmFsdWVzWzIwXSksXHJcbiAgICAgICAgICAgICAgICAgIGhlYWRpbmc6IHBhcnNlRmxvYXQodmFsdWVzWzIxXSksXHJcbiAgICAgICAgICAgICAgICAgIHBhcmFjaHV0ZTogcGFyc2VJbnQodmFsdWVzWzIyXSksXHJcbiAgICAgICAgICAgICAgICAgIGZsaWdodF9zdGF0ZTogcGFyc2VJbnQodmFsdWVzWzIzXSksXHJcbiAgICAgICAgICAgICAgICAgIHRpbWVfc2luY2Vfc3RhcnQ6IHBhcnNlRmxvYXQodmFsdWVzWzI0XSksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IFsuLi5kYXRhLCBuZXdEYXRhXTtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICB4OiBtYXBWYWx1ZVRvUmFuZ2UodmFsdWVzWzE4XSwgMCwgMzYwLCAtMTgwLCAxODApLFxyXG4gICAgICAgICAgICAgICAgICB5OiBtYXBWYWx1ZVRvUmFuZ2UodmFsdWVzWzIxXSwgMCwgMzYwLCAtMTgwLCAxODApLFxyXG4gICAgICAgICAgICAgICAgICB6OiBtYXBWYWx1ZVRvUmFuZ2UodmFsdWVzWzE5XSwgMCwgMzYwLCAtMTgwLCAxODApLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKFwiZmV0Y2gtZGF0YVwiLCBcIipcIik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICBzZXJpYWxwb3J0Lm9uKCdlcnJvcicsIChlcnIpID0+IHsgXHJcbiAgICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKFwic2VyaWFscG9ydC1lcnJvclwiLCBcIipcIik7XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBzZXJpYWxwb3J0Lm9uKCdjbG9zZScsICgpID0+IHtcclxuICAgICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoXCJzZXJpYWxwb3J0LWNsb3NlXCIsIFwiKlwiKTtcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChjb25uZWN0VG9EZXZpY2UsIDEwMDApO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGNvbm5lY3RUb0RldmljZSgpO1xyXG59XHJcblxyXG5jb25zdCBjbG9zZVN0cmVhbSA9IGFzeW5jICgpID0+IHtcclxuICBpZiAoc2VyaWFscG9ydCkge1xyXG4gICAgc2VyaWFscG9ydC5jbG9zZSgpO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgZ2V0RGF0YSA9ICgpID0+IHtcclxuICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuY29uc3QgZ2V0UG9zaXRpb24gPSAoKSA9PiB7XHJcbiAgcmV0dXJuIHBvc2l0aW9uO1xyXG59XHJcblxyXG5jb250ZXh0QnJpZGdlLmV4cG9zZUluTWFpbldvcmxkKFwiYmFja2VuZFwiLCB7XHJcbiAgZ2V0UG9ydHMsXHJcbiAgd3JpdGVQb3J0LFxyXG4gIHNhdmVEYXRhLFxyXG4gIGdldFN0cmVhbSxcclxuICBjbG9zZVN0cmVhbSxcclxuICBnZXREYXRhLFxyXG4gIGdldFBvc2l0aW9uXHJcbn0pIl0sIm5hbWVzIjpbIlNlcmlhbFBvcnQiLCJkYXRhIiwiaXBjUmVuZGVyZXIiLCJSZWFkbGluZVBhcnNlciIsImNvbnRleHRCcmlkZ2UiXSwibWFwcGluZ3MiOiI7Ozs7O0FBaUNBLElBQUk7QUFDSixJQUFJLE9BQWUsQ0FBQTtBQUNuQixJQUFJLFdBSUEsRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFFckIsU0FBUyxnQkFDUCxPQUNBLFFBQ0EsUUFDQSxRQUNBLFFBQ0E7QUFDQSxRQUFNLGdCQUFnQixTQUFTO0FBQy9CLFFBQU0sZ0JBQWdCLFNBQVM7QUFFekIsUUFBQSxtQkFBbUIsUUFBUSxVQUFVO0FBQ3JDLFFBQUEsV0FBVyxrQkFBa0IsZ0JBQWdCO0FBRTVDLFNBQUE7QUFDVDtBQUVBLE1BQU0sV0FBVyxZQUFZO0FBQ3JCLFFBQUEsUUFBUSxNQUFNQSx3QkFBVztBQUMvQixRQUFNLFlBQVksTUFBTSxJQUFJLENBQUEsU0FBUSxLQUFLLElBQUk7QUFDdEMsU0FBQTtBQUFBLElBQ0wsT0FBTztBQUFBLEVBQUE7QUFFWDtBQUVBLE1BQU0sWUFBWSxPQUFPQyxVQUFpQjtBQUN4QyxNQUFJLFlBQVk7QUFDZCxlQUFXLE1BQU1BLEtBQUk7QUFDckIsV0FBTyxFQUFFLFNB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
